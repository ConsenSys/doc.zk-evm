---
title: Module limits
description: How module limits ensure the prover can generate proofs.
sidebar_position: 3
---

Linea has a built-in mechanism for ensuring that the prover can continue to generate proofs
without increasing proof complexity to such a level that current infrastructure cannot process them. 
This buffer is represented by module limits. 

Modules are the sections into which Linea's arithmetization specification is divided. Each module 
represents a collection of operations (opcodes) at the EVM level, and corresponds to a specific 
function of Linea's zkEVM. Some of the modules process transaction data; some manage zkEVM memory; 
others coordinate interactions between modules.

Regardless of its purpose, each module has a specific limit to the amount of lines of data that 
its operations can generate. You can view each module's limits in the [Linea source code](https://github.com/Consensys/linea-monorepo/blob/main/config/common/traces-limits-besu-v2.toml).
Every time one of the operations in a module is 

Transactions with a high complexity—using a large volume of operations repeatedly—may generate too 
many lines of data, and exceed that module's limit. Transactions that reach this point are 
rejected by the [sequencer](../sequencer/index.mdx) to ensure that the trace data passed to the 
prover is of a manageable scope, and that a proof can be generated.
